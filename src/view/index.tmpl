<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>image quilt</title>
<style>
  :root { --gap: 0px; }

  html, body {
    height: 100%;
    width: 100%;
    margin: 0;
    padding: 0;
    background: #000;
  }

  body {
    display: grid;
    grid-template-columns: repeat(var(--cols), 1fr);
    grid-template-rows: repeat(var(--rows), 1fr);
    gap: var(--gap);
    height: 100vh;
    width: 100vw;
    overflow: hidden;
    box-sizing: border-box;
  }

  .tile {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #111;
  }

  .tile img,
  .tile video {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: fill;
    background: #000;
    display: block;
    user-select: none;
    opacity: 1;
  }

  .tile img.fade-out,
  .tile video.fade-out {
    z-index: 9999;
    transition: opacity 2s ease;
    opacity: 0;
  }

  .empty {
    color: #fff;
    display:flex;
    align-items:center;
    justify-content:center;
    height:100vh;
    width:100vw;
    font-family: sans-serif;
    font-size: 18px;
  }
</style>
</head>
<body>
<script>
(async () => {
  // CONFIG: change these if you want a different fixed grid
  const COLS = {%& COLUMNS %};
  const ROWS = {%& ROWS %};
  const TILE_COUNT = COLS * ROWS;
  const SWAP_INTERVAL_MS = {%& INTERVAL %} * 1000; // fixed 1 second per your request

  const getRandom = (n) => Math.floor(Math.random() * n);

  function createMediaElement(src) {
    const ext = src.split('.').pop().toLowerCase();
    if (['mp4', 'mkv', 'webm'].includes(ext)) {
      const vid = document.createElement('video');
      vid.src = src;
      vid.autoplay = true;
      vid.loop = true;
      // vid.muted = true;
      vid.playsInline = true;
      return vid;
    } else {
      const img = document.createElement('img');
      img.src = src;
      img.alt = '';
      img.draggable = false;
      return img;
    }
  }

  document.documentElement.style.setProperty('--cols', String(COLS));
  document.documentElement.style.setProperty('--rows', String(ROWS));

  let images = {};
  let seenImages = {};

  // Fetch image list from backend
  try {
    const r = await fetch('/images');
    const json = await r.json();
    images = json.images;
  } catch (e) {
    console.error('Failed to fetch /images', e);
    images = {};
  }

  // if no images, show error screen, and end execution
  if (!images || typeof images !== 'object') {
    document.body.innerHTML = '<div class="empty">No images found in the configured folder.</div>';
    return;
  }

  function getImage() {
    if (images.length === 0) {
      images = seenImages;
      seenImages = [];
    }

    const idx = getRandom(images.length);
    const [imagePath] = images.splice(idx, 1); // inefficient, but whatever
    seenImages.push(imagePath);
    return imagePath;
  }

  // Build the initial fixed tiles
  const tiles = [];
  for (let i = 0; i < TILE_COUNT; i++) {
    const container = document.createElement('div');
    container.className = 'tile';

    const imagePath = getImage();
    const img = createMediaElement(imagePath);

    container.appendChild(img);
    document.body.appendChild(container);
    tiles.push({ container, img, swapped: false });
  }

  // swap logic
  function doSwap(tile, newEl) {
    const oldEl = tile.img;
    tile.container.appendChild(newEl);

    oldEl.classList.add('fade-out');
    oldEl.addEventListener('transitionend', () => oldEl.remove(), { once: true });

    tile.img = newEl;
  }

  let tilesSwapped = 0;
  function preloadAndSwap(tile) {
    tile.swapped = true;
    tilesSwapped += 1;

    const next = getImage();
    // const pre = new Image();
    const newEl = createMediaElement(next);

    if (newEl.tagName === 'VIDEO') {
      doSwap(tile, newEl);
    } else {
      const pre = new Image();

      pre.onload = () => {
        doSwap(tile, newEl);
      };

      pre.onerror = () => console.warn('Preload failed for', next);
      pre.src = next;
    }
  }

  // replace a random tile every SWAP_INTERVAL_MS
  setInterval(() => {
    if (tilesSwapped >= TILE_COUNT) {
      tilesSwapped = 0;
      for (tile of tiles) {
        tile.swapped = false;
      }
    }

    let idx;
    do {
      idx = getRandom(tiles.length);
    } while (tiles[idx].swapped)

    preloadAndSwap(tiles[idx]);
  }, SWAP_INTERVAL_MS);
})();
</script>
</body>
</html>
